<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <link rel="icon" type="image/svg+xml" href="/vite.svg" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Vite + React + TS</title>
    </head>
    <body>
        <div id="root"></div>

        <!-- Console Log Interceptor -->
        <script>
            // Store original console methods
            const originalConsole = {
                log: console.log,
                error: console.error,
                warn: console.warn,
                info: console.info,
                debug: console.debug,
            };

            // Create log container
            const logContainer = document.createElement("div");
            logContainer.id = "console-logs";
            logContainer.style.cssText = `
                position: fixed;
                top: 10px;
                right: 10px;
                width: 400px;
                max-height: 60vh;
                background: rgba(0, 0, 0, 0.9);
                color: #00ff00;
                font-family: monospace;
                font-size: 12px;
                padding: 10px;
                border-radius: 5px;
                z-index: 9999;
                overflow-y: auto;
                border: 1px solid #333;
                display: none;
            `;

            // Add toggle button
            const toggleButton = document.createElement("button");
            toggleButton.textContent = "Show Logs";
            toggleButton.style.cssText = `
                position: fixed;
                top: 10px;
                right: 420px;
                background: #333;
                color: white;
                border: none;
                padding: 5px 10px;
                border-radius: 3px;
                cursor: pointer;
                z-index: 10000;
                font-size: 12px;
            `;

            let logsVisible = false;
            toggleButton.onclick = () => {
                logsVisible = !logsVisible;
                logContainer.style.display = logsVisible ? "block" : "none";
                toggleButton.textContent = logsVisible
                    ? "Hide Logs"
                    : "Show Logs";
            };

            document.body.appendChild(logContainer);
            document.body.appendChild(toggleButton);

            // Function to add log to display
            function addLogToDisplay(type, args, shouldStore = true) {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement("div");
                logEntry.style.marginBottom = "3px";
                logEntry.style.borderBottom = "1px solid #333";
                logEntry.style.paddingBottom = "2px";

                let color = "#00ff00";
                switch (type) {
                    case "error":
                        color = "#ff4444";
                        break;
                    case "warn":
                        color = "#ffaa00";
                        break;
                    case "info":
                        color = "#4444ff";
                        break;
                    case "debug":
                        color = "#888888";
                        break;
                }

                logEntry.innerHTML = `
                    <span style="color: #666; font-size: 10px;">[${timestamp}]</span>
                    <span style="color: ${color}; font-weight: bold;">[${type.toUpperCase()}]</span>
                    <span style="color: white;">
                        ${args
                            .map((arg) => {
                                if (typeof arg === "object") {
                                    try {
                                        return JSON.stringify(arg, null, 2);
                                    } catch (e) {
                                        return String(arg);
                                    }
                                }
                                return String(arg);
                            })
                            .join(" ")}
                    </span>
                `;

                logContainer.appendChild(logEntry);
                logContainer.scrollTop = logContainer.scrollHeight;

                // Limit to last 100 logs
                while (logContainer.children.length > 100) {
                    logContainer.removeChild(logContainer.firstChild);
                }

                // Store in IndexedDB if requested
                if (shouldStore) {
                    storeConsoleLog(type, args);

                    // Also send to API
                    const logData = {
                        timestamp: Date.now(),
                        time: timestamp,
                        logType: type,
                        args: args.map((arg) => {
                            if (typeof arg === "object") {
                                try {
                                    return JSON.stringify(arg);
                                } catch (e) {
                                    return String(arg);
                                }
                            }
                            return String(arg);
                        }),
                        message: args.map((arg) => String(arg)).join(" "),
                    };

                    sendToAPI("logs", logData);
                }
            }

            // Override console methods
            console.log = function (...args) {
                originalConsole.log.apply(console, args);
                addLogToDisplay("log", args);
            };

            console.error = function (...args) {
                originalConsole.error.apply(console, args);
                addLogToDisplay("error", args);
            };

            console.warn = function (...args) {
                originalConsole.warn.apply(console, args);
                addLogToDisplay("warn", args);
            };

            console.info = function (...args) {
                originalConsole.info.apply(console, args);
                addLogToDisplay("info", args);
            };

            console.debug = function (...args) {
                originalConsole.debug.apply(console, args);
                addLogToDisplay("debug", args);
            };

            // Catch unhandled errors
            window.addEventListener("error", function (e) {
                addLogToDisplay("error", [
                    `Unhandled Error: ${e.message}`,
                    `File: ${e.filename}:${e.lineno}:${e.colno}`,
                ]);
            });

            // Catch unhandled promise rejections
            window.addEventListener("unhandledrejection", function (e) {
                addLogToDisplay("error", [
                    `Unhandled Promise Rejection:`,
                    e.reason,
                ]);
            });

            // IndexedDB Storage for Logs
            let db = null;
            const DB_NAME = "DevLogsDB";
            const DB_VERSION = 1;
            const CONSOLE_STORE = "consoleLogs";
            const NETWORK_STORE = "networkLogs";
            const MAX_CONSOLE_LOGS = 100;
            const MAX_NETWORK_LOGS = 100;

            // Initialize IndexedDB
            function initDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);

                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        db = request.result;
                        resolve(db);
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;

                        // Create console logs store
                        if (!db.objectStoreNames.contains(CONSOLE_STORE)) {
                            const consoleStore = db.createObjectStore(
                                CONSOLE_STORE,
                                { keyPath: "id", autoIncrement: true },
                            );
                            consoleStore.createIndex("timestamp", "timestamp", {
                                unique: false,
                            });
                        }

                        // Create network logs store
                        if (!db.objectStoreNames.contains(NETWORK_STORE)) {
                            const networkStore = db.createObjectStore(
                                NETWORK_STORE,
                                { keyPath: "id", autoIncrement: true },
                            );
                            networkStore.createIndex("timestamp", "timestamp", {
                                unique: false,
                            });
                        }
                    };
                });
            }

            // Store console log in IndexedDB
            async function storeConsoleLog(type, args) {
                if (!db) return;

                const transaction = db.transaction(
                    [CONSOLE_STORE],
                    "readwrite",
                );
                const store = transaction.objectStore(CONSOLE_STORE);

                const logEntry = {
                    timestamp: Date.now(),
                    time: new Date().toLocaleTimeString(),
                    type: type,
                    args: args.map((arg) => {
                        if (typeof arg === "object") {
                            try {
                                return JSON.stringify(arg);
                            } catch (e) {
                                return String(arg);
                            }
                        }
                        return String(arg);
                    }),
                };

                await store.add(logEntry);

                // Maintain rolling buffer - keep only latest MAX_CONSOLE_LOGS
                const countRequest = store.count();
                countRequest.onsuccess = () => {
                    if (countRequest.result > MAX_CONSOLE_LOGS) {
                        const deleteCount =
                            countRequest.result - MAX_CONSOLE_LOGS;
                        const cursorRequest = store.openCursor();
                        let deleted = 0;

                        cursorRequest.onsuccess = (event) => {
                            const cursor = event.target.result;
                            if (cursor && deleted < deleteCount) {
                                cursor.delete();
                                deleted++;
                                cursor.continue();
                            }
                        };
                    }
                };
            }

            // Store network log in IndexedDB
            async function storeNetworkLog(
                method,
                url,
                status,
                requestData,
                responseData,
                duration,
                responseHeaders,
            ) {
                if (!db) return;

                const transaction = db.transaction(
                    [NETWORK_STORE],
                    "readwrite",
                );
                const store = transaction.objectStore(NETWORK_STORE);

                const logEntry = {
                    timestamp: Date.now(),
                    time: new Date().toLocaleTimeString(),
                    method: method,
                    url: url,
                    status: status,
                    requestData: requestData,
                    responseData: responseData,
                    responseHeaders: responseHeaders,
                    duration: duration,
                };

                await store.add(logEntry);

                // Maintain rolling buffer - keep only latest MAX_NETWORK_LOGS
                const countRequest = store.count();
                countRequest.onsuccess = () => {
                    if (countRequest.result > MAX_NETWORK_LOGS) {
                        const deleteCount =
                            countRequest.result - MAX_NETWORK_LOGS;
                        const cursorRequest = store.openCursor();
                        let deleted = 0;

                        cursorRequest.onsuccess = (event) => {
                            const cursor = event.target.result;
                            if (cursor && deleted < deleteCount) {
                                cursor.delete();
                                deleted++;
                                cursor.continue();
                            }
                        };
                    }
                };
            }

            // Load console logs from IndexedDB
            async function loadConsoleLogsFromDB() {
                if (!db) return [];

                return new Promise((resolve) => {
                    const transaction = db.transaction(
                        [CONSOLE_STORE],
                        "readonly",
                    );
                    const store = transaction.objectStore(CONSOLE_STORE);
                    const request = store.getAll();

                    request.onsuccess = () => {
                        const logs = request.result.sort(
                            (a, b) => b.timestamp - a.timestamp,
                        );
                        logs.forEach((log) => {
                            addLogToDisplay(log.type, log.args, false); // false = don't store again
                        });
                        resolve(logs);
                    };

                    request.onerror = () => resolve([]);
                });
            }

            // Load network logs from IndexedDB
            async function loadNetworkLogsFromDB() {
                if (!db) return [];

                return new Promise((resolve) => {
                    const transaction = db.transaction(
                        [NETWORK_STORE],
                        "readonly",
                    );
                    const store = transaction.objectStore(NETWORK_STORE);
                    const request = store.getAll();

                    request.onsuccess = () => {
                        const logs = request.result.sort(
                            (a, b) => b.timestamp - a.timestamp,
                        );
                        logs.forEach((log) => {
                            addNetworkLogToDisplay(
                                log.method,
                                log.url,
                                log.status,
                                log.requestData,
                                log.responseData,
                                log.duration,
                                log.responseHeaders,
                                false, // false = don't store again
                            );
                        });
                        resolve(logs);
                    };

                    request.onerror = () => resolve([]);
                });
            }

            // Configuration from environment variables
            const CONFIG = {
                HOST_API: "<%= hostApi %>",
                PROJECT_ID: "<%= projectId %>",
                BACKEND_URL: "<%= backendUrl %>",
            };

            // Rate limiting for API calls
            const rateLimits = {
                logs: { lastSent: 0, minInterval: 100 }, // Max 10 per second
                network: { lastSent: 0, minInterval: 50 }, // Max 20 per second
            };

            // Send logs to API endpoint with rate limiting and loop prevention
            async function sendToAPI(type, data) {
                // Rate limiting
                const now = Date.now();
                const rateLimit = rateLimits[type];
                if (now - rateLimit.lastSent < rateLimit.minInterval) {
                    return; // Skip if too frequent
                }
                rateLimit.lastSent = now;

                try {
                    const response = await fetch(
                        `http://${CONFIG.HOST_API}/${CONFIG.PROJECT_ID}/server_info`,
                        {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                                "X-Monitor-Request": "true", // Mark as monitoring request
                            },
                            body: JSON.stringify({
                                type: type, // 'logs' or 'network'
                                ...data,
                            }),
                        },
                    );

                    if (!response.ok) {
                        originalConsole.error(
                            `Failed to send ${type} to API:`,
                            response.status,
                        );
                    }
                } catch (error) {
                    originalConsole.error(
                        `Error sending ${type} to API:`,
                        error,
                    );
                }
            }

            // Initialize DB and load existing logs
            initDB()
                .then(() => {
                    originalConsole.log("IndexedDB initialized");
                    originalConsole.log("Config:", CONFIG);
                    loadConsoleLogsFromDB();
                    loadNetworkLogsFromDB();
                })
                .catch((err) => {
                    originalConsole.error(
                        "Failed to initialize IndexedDB:",
                        err,
                    );
                });

            // Initial log to confirm it's working
            originalConsole.log("Console log interceptor initialized");

            // Network Request Monitor
            const networkLogs = [];

            // Create network log container
            const networkContainer = document.createElement("div");
            networkContainer.id = "network-logs";
            networkContainer.style.cssText = `
                position: fixed;
                top: 10px;
                left: 10px;
                width: 500px;
                max-height: 60vh;
                background: rgba(0, 0, 0, 0.9);
                color: #00ccff;
                font-family: monospace;
                font-size: 11px;
                padding: 10px;
                border-radius: 5px;
                z-index: 9998;
                overflow-y: auto;
                border: 1px solid #333;
                display: none;
            `;

            // Add network toggle button
            const networkToggleButton = document.createElement("button");
            networkToggleButton.textContent = "Show Network";
            networkToggleButton.style.cssText = `
                position: fixed;
                top: 10px;
                left: 520px;
                background: #0066cc;
                color: white;
                border: none;
                padding: 5px 10px;
                border-radius: 3px;
                cursor: pointer;
                z-index: 10000;
                font-size: 12px;
            `;

            let networkVisible = false;
            networkToggleButton.onclick = () => {
                networkVisible = !networkVisible;
                networkContainer.style.display = networkVisible
                    ? "block"
                    : "none";
                networkToggleButton.textContent = networkVisible
                    ? "Hide Network"
                    : "Show Network";
            };

            document.body.appendChild(networkContainer);
            document.body.appendChild(networkToggleButton);

            // Function to add network log to display
            function addNetworkLogToDisplay(
                method,
                url,
                status,
                requestData,
                responseData,
                duration,
                responseHeaders = null,
                shouldStore = true,
            ) {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement("div");
                logEntry.style.cssText = `
                    margin-bottom: 8px;
                    border: 1px solid #444;
                    border-radius: 3px;
                    padding: 8px;
                    background: rgba(0, 0, 0, 0.3);
                `;

                let statusColor = "#00ff00";
                if (status >= 400) statusColor = "#ff4444";
                else if (status >= 300) statusColor = "#ffaa00";
                else if (status >= 200) statusColor = "#00ff00";

                const shortUrl = url.length > 50 ? "..." + url.slice(-47) : url;

                logEntry.innerHTML = `
                    <div style="margin-bottom: 4px;">
                        <span style="color: #666; font-size: 10px;">[${timestamp}]</span>
                        <span style="color: #ffcc00; font-weight: bold;">${method}</span>
                        <span style="color: white; margin-left: 8px;">${shortUrl}</span>
                        <span style="color: ${statusColor}; margin-left: 8px; font-weight: bold;">${status || "PENDING"}</span>
                        ${duration ? `<span style="color: #888; margin-left: 8px;">${duration}ms</span>` : ""}
                    </div>
                    ${
                        requestData
                            ? `
                        <details style="margin-top: 4px;">
                            <summary style="color: #88ccff; cursor: pointer; font-size: 10px;">📤 REQUEST</summary>
                            <pre style="color: #ccc; font-size: 10px; margin: 4px 0; white-space: pre-wrap; max-height: 150px; overflow-y: auto;">${requestData}</pre>
                        </details>
                    `
                            : ""
                    }
                    ${
                        responseHeaders
                            ? `
                        <details style="margin-top: 4px;">
                            <summary style="color: #ff88cc; cursor: pointer; font-size: 10px;">📋 RESPONSE HEADERS</summary>
                            <pre style="color: #ccc; font-size: 10px; margin: 4px 0; white-space: pre-wrap; max-height: 150px; overflow-y: auto;">${responseHeaders}</pre>
                        </details>
                    `
                            : ""
                    }
                    ${
                        responseData
                            ? `
                        <details style="margin-top: 4px;">
                            <summary style="color: #88ffcc; cursor: pointer; font-size: 10px;">📥 RESPONSE BODY</summary>
                            <pre style="color: #ccc; font-size: 10px; margin: 4px 0; white-space: pre-wrap; max-height: 150px; overflow-y: auto;">${responseData}</pre>
                        </details>
                    `
                            : ""
                    }
                `;

                networkContainer.insertBefore(
                    logEntry,
                    networkContainer.firstChild,
                );

                // Limit to last 100 network logs
                while (networkContainer.children.length > 100) {
                    networkContainer.removeChild(networkContainer.lastChild);
                }

                // Store in IndexedDB if requested
                if (shouldStore) {
                    storeNetworkLog(
                        method,
                        url,
                        status,
                        requestData,
                        responseData,
                        duration,
                        responseHeaders,
                    );

                    // Also send to API
                    const networkData = {
                        timestamp: Date.now(),
                        time: timestamp,
                        method: method,
                        url: url,
                        status: status,
                        duration: duration,
                        requestData: requestData,
                        responseData: responseData,
                        responseHeaders: responseHeaders,
                    };

                    sendToAPI("network", networkData);
                }
            }

            // Store original fetch
            const originalFetch = window.fetch;

            // Override fetch
            window.fetch = function (...args) {
                const startTime = performance.now();
                const [url, options = {}] = args;
                const method = options.method || "GET";

                // Skip monitoring for our own monitoring requests
                const isMonitoringRequest =
                    options.headers &&
                    options.headers["X-Monitor-Request"] === "true";
                const isServerInfoURL =
                    typeof url === "string" && url.includes("/server_info");

                if (isMonitoringRequest || isServerInfoURL) {
                    return originalFetch.apply(this, args);
                }

                let requestData = "";
                if (options.body) {
                    try {
                        if (typeof options.body === "string") {
                            requestData = JSON.stringify(
                                JSON.parse(options.body),
                                null,
                                2,
                            );
                        } else {
                            requestData = options.body.toString();
                        }
                    } catch (e) {
                        requestData = options.body.toString();
                    }
                }

                // Add headers to request data
                if (options.headers) {
                    const headersStr = JSON.stringify(options.headers, null, 2);
                    requestData = `HEADERS:\n${headersStr}\n\nBODY:\n${requestData}`;
                }

                // Don't log to console to avoid duplication in console logs

                return originalFetch
                    .apply(this, args)
                    .then((response) => {
                        const duration = Math.round(
                            performance.now() - startTime,
                        );

                        // Clone response to read body without consuming it
                        const responseClone = response.clone();

                        responseClone
                            .text()
                            .then((responseText) => {
                                let responseData = "";
                                try {
                                    const jsonResponse =
                                        JSON.parse(responseText);
                                    responseData = JSON.stringify(
                                        jsonResponse,
                                        null,
                                        2,
                                    );
                                } catch (e) {
                                    responseData = responseText;
                                }

                                // Extract response headers
                                let responseHeadersStr = "";
                                const headersObj = {};
                                for (const [
                                    key,
                                    value,
                                ] of response.headers.entries()) {
                                    headersObj[key] = value;
                                }
                                responseHeadersStr = JSON.stringify(
                                    headersObj,
                                    null,
                                    2,
                                );

                                addNetworkLogToDisplay(
                                    method,
                                    url,
                                    response.status,
                                    requestData,
                                    responseData,
                                    duration,
                                    responseHeadersStr,
                                );
                                // Don't log to console to avoid duplication in console logs
                            })
                            .catch(() => {
                                addNetworkLogToDisplay(
                                    method,
                                    url,
                                    response.status,
                                    requestData,
                                    "Could not read response body",
                                    duration,
                                );
                            });

                        return response;
                    })
                    .catch((error) => {
                        const duration = Math.round(
                            performance.now() - startTime,
                        );
                        addNetworkLogToDisplay(
                            method,
                            url,
                            "ERROR",
                            requestData,
                            `Error: ${error.message}`,
                            duration,
                            null,
                        );
                        // Don't log to console to avoid duplication in console logs
                        throw error;
                    });
            };

            // Override XMLHttpRequest
            const originalXHROpen = XMLHttpRequest.prototype.open;
            const originalXHRSend = XMLHttpRequest.prototype.send;

            XMLHttpRequest.prototype.open = function (
                method,
                url,
                async,
                user,
                password,
            ) {
                this._method = method;
                this._url = url;
                this._startTime = performance.now();
                return originalXHROpen.apply(this, arguments);
            };

            XMLHttpRequest.prototype.send = function (data) {
                const xhr = this;

                let requestData = "";
                if (data) {
                    try {
                        if (typeof data === "string") {
                            requestData = JSON.stringify(
                                JSON.parse(data),
                                null,
                                2,
                            );
                        } else {
                            requestData = data.toString();
                        }
                    } catch (e) {
                        requestData = data.toString();
                    }
                }

                // Don't log to console to avoid duplication in console logs

                const originalOnReadyStateChange = xhr.onreadystatechange;

                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        const duration = Math.round(
                            performance.now() - xhr._startTime,
                        );
                        let responseData = "";

                        try {
                            const jsonResponse = JSON.parse(xhr.responseText);
                            responseData = JSON.stringify(
                                jsonResponse,
                                null,
                                2,
                            );
                        } catch (e) {
                            responseData = xhr.responseText;
                        }

                        // Extract response headers for XHR
                        let responseHeadersStr = "";
                        try {
                            const headersObj = {};
                            const headerStr = xhr.getAllResponseHeaders();
                            if (headerStr) {
                                headerStr.split("\r\n").forEach((line) => {
                                    const parts = line.split(": ");
                                    if (parts.length === 2) {
                                        headersObj[parts[0]] = parts[1];
                                    }
                                });
                                responseHeadersStr = JSON.stringify(
                                    headersObj,
                                    null,
                                    2,
                                );
                            }
                        } catch (e) {
                            responseHeadersStr = "Could not extract headers";
                        }

                        addNetworkLogToDisplay(
                            xhr._method,
                            xhr._url,
                            xhr.status,
                            requestData,
                            responseData,
                            duration,
                            responseHeadersStr,
                        );
                        // Don't log to console to avoid duplication in console logs
                    }

                    if (originalOnReadyStateChange) {
                        originalOnReadyStateChange.apply(xhr, arguments);
                    }
                };

                return originalXHRSend.apply(this, arguments);
            };

            originalConsole.log("Network request monitor initialized");
        </script>

        <script type="module" src="/src/main.tsx"></script>
    </body>
</html>
